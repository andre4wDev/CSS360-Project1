# Group Section (Project #1)

## #4: Department of Transportation

[Jump to Key Aspects](#key-aspects-that-mattered-most)

> Final team decision: **Waterfall**

### Final Team SDLC Choice

**Waterfall**

### Why Waterfall is a Good Fit

For this project waterfall seemed to be the best fit due to it's linear approach to the system that is being created. 
With the existing documentation for the project, being able to go through development and getting approved each step of the way was a huge bonus.
Especially given the 18 month time constraint, it was important that this solution was streamlined. 
Not to mention the fact that this team already has experience building similar such systems, waterfall makes the most sense here.

### Other Models We Considered

1. **RAD (Rapid Application Development)**
   RAD was a good option because the site already uses in-house templates and expects us to reuse the same tools with minor changes. RAD works well with reusable components and quick iterations, which can speed up development and support fast feedback. We did not pick RAD as the final choice because we still have a lot of coordination work with the interpreter team and evolving feature priorities, and Agile gives us a stronger structure for sprint planning, backlog changes, and ongoing stakeholder feedback.

2. **Incremental**
   Incremental also made sense because we could deliver a basic store first, then add customization and outfit matching later. Agile won out because it is more flexible when requirements are unclear, and it pushes continuous customer feedback instead of just adding features in a fixed sequence.

### Key Aspects That Mattered Most

* **Unclear and evolving requirements**
  This is critical because the user experience goals are big, but the exact features that will keep customers coming back will take testing and iteration. Agile supports learning quickly and changing direction without wasting a ton of time.

* **Dependencies on the interpreter team and reused tools**
  This is critical because parts of the work depend on another group updating the Java interpreter and template system. Agile helps us coordinate, adjust scope, and keep progress moving even when dependencies shift.


